
1514104972 
图论模板
 admin  2021-10-03 08:56:14

1.1 图的邻接表存储――链表形式
#include<iostream>
using namespace std;
const int MAXN = 10005,MAXE = 10005<<1;
int head[MAXN],e,n,cnt;//总共n个点 e条边
// cnt 记录当前统计到第几条边 
struct Edge{
	int next,v,dis;
}; 
Edge edge[MAXE];
void add_edge(int u,int v,int dis){
	++cnt;
	edge[cnt].next = head;
	head = cnt;
	edge[cnt].v = v;
	edge[cnt].dis = dis;
}
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		int u,v;
		cin>>u>>v;
		add_edge(u,v,1);
	}
	for(int i=0;i<=n;++i){
		cout<<i<<"的邻接点有：";
		for(int j=head;j!=0;j=edge[j].next){
			cout<<edge[j].v<<" ";
		}
		cout<<endl; 
	} 
	return 0;
}

1.2 图的邻接表存储――STL形式
#include<iostream>
#include<vector>
using namespace std;
const int MAXN = 10005;
struct Edge{
	int v,d;
};
vector<Edge> G[MAXN];
void add_edge(int u,int v,int d){
	Edge e;e.v = v;e.d = d;
	G.push_back(e);
}
int n,e;
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		int u,v;
		cin>>u>>v;
		add_edge(u,v,1);
		add_edge(v,u,1);
	}
	for(int i=0;i<=n;++i){
		int sz = G.size();
		cout<<i<<"的邻接点有：";
		for(int j=0;j<sz;++j){
			cout<<G[j].v<<" ";
		}
		cout<<endl;
	}
	return 0;
}

1.3 图的邻接矩阵存储
#include<iostream>
using namespace std;
const int MAXN = 1005;
int G[MAXN][MAXN],n,e; 
// 该图有 n 个点，e 条边 
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		int u,v;
		cin>>u>>v;
		G[v] = 1;
		G[v] = 1;
	}
	for(int i=0;i<=n;++i){
		cout<<i<<"的邻接点有：";
		for(int j=0;j<=n;++j){
			if(G[j]==1){
				cout<<j<<" ";
			} 
		}
		cout<<endl;
	}
	return 0;
}

2.1 邻接表的DFS
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
const int MAXN = 110,MAXE = 10010;
struct Edge{
	int to,dis;
};
vector<Edge> G[MAXN];
void add_edge(int u,int v,int d){
	Edge temp;
	temp.to = v;temp.dis = d;
	G.push_back(temp);
}
int vis[MAXN],n,e,u,v,d;
void DFS(int be){
	cout<<be<<" ";
	vis[be] = 1;
	int sz = G[be].size();
	for(int i=0;i<sz;++i){
		if(vis[G[be].to]==0){
			DFS(G[be].to);
		}
	}
}
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		cin>>u>>v>>d; 
		add_edge(u,v,d);
		add_edge(v,u,d);
	} 
	DFS(0);
	return 0;
}

2.2 邻接矩阵的DFS
#include<iostream>
#include<cstdio>
using namespace std;
const int MAXN = 100;
int G[MAXN][MAXN],vis[MAXN];
int n,e,u,v,d; 
int DFS(int be){
	cout<<be<<" ";
	vis[be] = 1;
	for(int i=n;i>=0;--i){
		if(G[be]!=0&&vis==0){
			DFS(i);
		}
	}
}
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		cin>>u>>v>>d;
		G[v] = d;
		G[v] = d;
	}
	DFS(0);
	return 0;
}

3.1 邻接矩阵的BFS
#include<iostream>
#include<cstdio>
using namespace std;
const int MAXN = 110;
int G[MAXN][MAXN],vis[MAXN],q[MAXN],h,t;
int n,e,u,v,d;
void BFS(int be){
	h = t = 0;
	q[t++] = be;
	while(h<t){
		int front = q[h];
		for(int i=0;i<=n;++i){
			if(G[front]!=0&&vis==0){
				q[t++] = i;
				vis = 1;
			}
		}
		cout<<q[h++]<<" ";
	} 
	return ;
}
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		cin>>u>>v>>d;
		G[v] = d;
		G[v] = d;
	}
	BFS(0);
	return 0;
}

3.2 邻接表的BFS
#include<iostream>
#include<cstdio>
using namespace std;
const int MAXN = 110,MAXE = 10010;
struct Edge{
	int to,dis,next;
	/*to 终点		dis 边权	next 下一条边的位置 */ 
};
Edge edge[MAXE]; 
int head[MAXN],n,e,cnt;
int vis[MAXN];
void add_edge(int from,int to,int dis){
	++cnt;
	edge[cnt].next = head[from];
	head[from] = cnt;
	edge[cnt].to = to;
	edge[cnt].dis = dis;
} 
void DFS(int be){
	cout<<be<<" ";
	vis[be] = 1;
	for(int i=head[be];i!=0;i=edge.next){
		if(vis[edge.to]==0){
			DFS(edge.to);
		}
	} 
}
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		int u,v,d;
		cin>>u>>v>>d;
		add_edge(u,v,d);
		add_edge(v,u,d);
	}
	DFS(0);
	return 0;
}

3.3 STL的BFS
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
const int MAXN = 110;
struct Edge{
	int to,dis;
};
vector<Edge> G[MAXN];
void add_edge(int u,int v,int d){
	G.push_back({v,d});
} 
int n,e,u,v,d,q[MAXN],h,t,vis[MAXN];
void BFS(int be){
	h = t = 0;
	q[t++] = be;
	vis[be] = 1;
	while(h<t){
		int temp = q[h];
		int sz = G[temp].size();
		for(int i=0;i<sz;++i){
			if(vis[G[temp].to]==0){
				vis[G[temp].to] = 1;
				q[t++] = G[temp].to; 
			}
		} 
		cout<<q[h++]<<" ";
	}
}
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		cin>>u>>v>>d;
		add_edge(u,v,d);
		add_edge(v,u,d);
	} 
	BFS(0);
	return 0;
}

4.1 Dijkstra 邻接矩阵
#include<iostream>
#include<cstdio>
using namespace std;
const int MAXN = 110;
int G[MAXN][MAXN],dis[MAXN],vis[MAXN],pre[MAXN];
int n,e,u,v,d;
void Dijkstra(int be){
	for(int i=0;i<=MAXN;++i){
		dis = 0x7fffffff;
	}
	dis[be] = 0;
	for(int k=1;k<=n;++k){
		int tx = -1,tp = 0x7fffffff;
		for(int i=0;i<=n;++i){
			if(vis==0){
				if(dis<tp){
					tx = i;
					tp = dis;
				}
			}
		}
		for(int i=0;i<=n;++i){
			if(G[tx]!=0&&vis==0)
			if(dis[tx]+G[tx]<dis){
				dis = dis[tx]+G[tx];
				pre = tx;
			}
		}
		vis[tx] = 1;
	} 
}
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		cin>>u>>v>>d;
		G[v] = d;
		G[v] = d;
	}
	Dijkstra(0);
	for(int i=0;i<=n;++i){
		cout<<i<<" "<<dis<<endl;
		for(int j=i;j!=0;j=pre[j]){
			cout<<j<<"->";
		}
		cout<<0;
		cout<<endl;
	}
	return 0;
}

4.2 Dijkstra 邻接表链表形式
#include<iostream>
#include<cstdio>
using namespace std;
const int MAXN = 110,MAXE = 10010;
int head[MAXN];
struct Edge{
	int to,dis,next;
};
Edge edge[MAXE];
int cnt;
void add_edge(int u,int v,int d){
	++cnt;
	edge[cnt].next = head;
	head = cnt;
	edge[cnt].to = v;
	edge[cnt].dis = d;
}
int n,e,u,v,d,dis[MAXN],pre[MAXN],vis[MAXN];
void Dijkstra(int be){
	for(int i=0;i<=n;++i){
		dis = 0x7fffffff;
	}
	dis[be] = 0;
	for(int k=0;k<=n;++k){
		int tx = 0x7fffffff,tp = -1;
		for(int i=0;i<=n;++i){
			if(vis==0){
				if(dis<tx){
					tx = dis;
					tp = i;
				}
			}
		}
		vis[tp] = 1;
		for(int i=head[tp];i!=0;i=edge.next){
			int to = edge.to;
			if(dis[to]>dis[tp]+edge.dis){
				dis[to] = dis[tp] + edge.dis;
				pre[to] =tp;
			}
		}
	} 
}
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		cin>>u>>v>>d;
		add_edge(u,v,d);
		add_edge(v,u,d);
	}
	Dijkstra(0);
	pre[0] = -1;
	for(int i=0;i<=n;++i){
		cout<<i<<" "<<dis<<endl;
		for(int j=i;j!=-1;j=pre[j]){
			cout<<j<<"->";
		}
		cout<<endl;
	}
	return 0;
}

4.3 Dijkstra 的邻接表STL
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
const int MAXN = 110;
const int INF = 0x7fffffff;
struct Edge{
	int to,dis;
};
vector<Edge> G[MAXN];
void add_edge(int u,int v,int d){
	Edge e;
	e.to = v;e.dis = d;
	G.push_back(e);
}
int n,e,u,v,d,dis[MAXN],vis[MAXN],pre[MAXN];
void Dijkstra(int be){
	for(int i=0;i<=MAXN;++i){
		dis = INF;
		vis = 0;
	}
	dis[be] = 0;
	for(int k=0;k<=n;++k){
		int tx = INF,tp = -1;
		for(int i=0;i<=n;++i){
			if(vis==0&&dis<tx){
				tx = dis;
				tp = i;
			}
		}
		vis[tp] = 1;
		int sz = G[tp].size();
		for(int i=0;i<sz;++i){
			if(dis[G[tp].to]>dis[tp] + G[tp].dis){
				dis[G[tp].to] = dis[tp] + G[tp].dis;
				pre[G[tp].to] = tp; 
			}
		}
	}
}
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		cin>>u>>v>>d;
		add_edge(u,v,d);
		add_edge(v,u,d);
	}
	Dijkstra(0);
	pre[0] = -1;
	for(int i=0;i<=n;++i){
		cout<<i<<" "<<dis<<endl;
		for(int j=i;j!=-1;j=pre[j]){
			cout<<j<<"->";
		}
		cout<<endl;
	}
	return 0;
}

4.4 Djikstra 的优先队列优化
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
const int MAXN = 110;
const int INF = 0x7fffffff;
struct Edge{
	int to,dis;
};
vector<Edge> G[MAXN];
struct Dis{
	int i,dis;
	friend bool operator < (Dis x,Dis y){
		x.dis>y.dis;
	}
};
priority_queue<Dis> pq;
void add_edge(int u,int v,int d){
	Edge e;
	e.to = v;e.dis = d;
	G.push_back(e);
} 
int n,e,u,v,d,pre[MAXN],vis[MAXN],dis[MAXN];
int Dijkstra(int be){
	for(int i=0;i<=n;++i){
		dis = INF;
	}
	dis[be] = 0;
	Dis temp;
	temp.i = be;
	temp.dis = 0;
	pq.push(temp);
	while(!pq.empty()){
		int td = pq.top().dis;
		int tp = pq.top().i;
		int sz = G[tp].size();
		pq.pop();
		for(int i=0;i<sz;++i){
			int des = G[tp].to;
			int cost = G[tp].dis;
			if(dis[des]>dis[tp]+cost){
				dis[des] = dis[tp]+cost;
				pre[des] = tp;
				pq.push({des,dis[des]});
			}
		} 
	}
}
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i){
		cin>>u>>v>>d;
		add_edge(u,v,d);
		add_edge(v,u,d);
	}
	Dijkstra(0);
	pre[0] = -1;
	for(int i=0;i<=n;++i){
		cout<<i<<" "<<dis<<endl;
		for(int j=i;j!=-1;j=pre[j]){
			cout<<j<<"->";
		}
		cout<<endl;
	}
	return 0;
}

5.1 Bellman_Ford 邻接表链表形式
#include<iostream>
#include<cstdio>
using namespace std;
const int MAXN = 110,MAXE = 10010;
const int INF = 1e9; 
struct Edge{
	int from,to,dis,next;
}; 
Edge edge[MAXE];
int cnt,head[MAXN],dis[MAXN];
void add_edge(int u,int v,int d){
	++cnt;
	edge[cnt].next = head;
	head = cnt;
	edge[cnt].from = u;
	edge[cnt].to = v;
	edge[cnt].dis = d;
}
int u,v,d,n,e;
int Bellman_Ford(int be){
	for(int i=0;i<=n;++i){
		dis = INF;
	}
	dis[be] = 0;
	for(int k=1;k<n;++k){
		int flag = 0;
		for(int i=1;i<=cnt;++i){
			int from = edge.from;
			int to = edge.to;
			int ds = edge.dis;
			if(dis[to]>dis[from]+ds){
				dis[to] = dis[from] + ds; 
				flag = 1;
			}
		} 
		if(flag == 0){
			return 0;
		}
	}
	int flag = 0;
	for(int i=1;i<=cnt;++i){
		int from = edge.from;
		int to = edge.to;
		int ds = edge.dis;
		if(dis[to]>dis[from]+ds){
			dis[to] = dis[from] + ds; 
			flag = 1;
		}
	}
	if(flag!=0){
		return 1;
	}else{
		return 0;
	}
}
int main(){
	cin>>n>>e;
	for(int i=1;i<=e;++i) {
		cin>>u>>v>>d;
		add_edge(u,v,d);
		add_edge(v,u,d);
	}
	Bellman_Ford(0);
	for(int i=0;i<=n;++i){
		printf("%d %d\n",i,dis);
	}

}

5.2 Bellman_Ford 邻接表STL
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+1;
const int INF = 1e9+7;
vector<pair<int,int> > E[MAXN];
int dis[MAXN],n,e,u,v,d;
int Bellman_Ford(int be){
	for(int i=0;i<=n;++i){
		dis = INF;
	}
	dis[be] = 0;
	for(int k=1;k<= n;++k){
		int f = 0;
		for(int i=0;i<=n;++i){
			for(int j=0;j<E.size();++j){
				int to = E[j].first;
				int dist = E[j].second;
				if(dis[to]>dis+dist){
					dis[to] = dis + dist;
					f = 1;
				}
			}
		}
		if(f==0){
			return 0;
		}
	}
	int f = 0;
	for(int i=0;i<=n;++i){
		for(int j=0;j<E.size();++j){
			int to = E[j].first;
			int dist = E[j].second;
			if(dis[to]>dis+dist){
				dis[to] = dis+dist;
				f = 1;
			} 
		}
	}
	if(f==0){
		return 0;
	}else{
		return 1;
	}
} 
int main(){
	scanf("%d %d",&n,&e);
	for(int i=1;i<=e;++i){
		scanf("%d %d %d",&u,&v,&d);
		E.push_back(pair<int,int>(v,d));
		E[v].push_back(pair<int,int>(u,d));
	}
	Bellman_Ford(0);
	for(int i=0;i<=n;++i){
		printf("%d %d\n",i,dis);
	}
	return 0;
}

6.1 SPFA
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+1;
const int INF = 1e9+7;
vector<pair<int,int> > E[MAXN];
int dis[MAXN],n,e,u,v,d;
int Bellman_Ford(int be){
	for(int i=0;i<=n;++i){
		dis = INF;
	}
	dis[be] = 0;
	for(int k=1;k<= n;++k){
		int f = 0;
		for(int i=0;i<=n;++i){
			for(int j=0;j<E.size();++j){
				int to = E[j].first;
				int dist = E[j].second;
				if(dis[to]>dis+dist){
					dis[to] = dis + dist;
					f = 1;
				}
			}
		}
		if(f==0){
			return 0;
		}
	}
	int f = 0;
	for(int i=0;i<=n;++i){
		for(int j=0;j<E.size();++j){
			int to = E[j].first;
			int dist = E[j].second;
			if(dis[to]>dis+dist){
				dis[to] = dis+dist;
				f = 1;
			} 
		}
	}
	if(f==0){
		return 0;
	}else{
		return 1;
	}
} 
int main(){
	scanf("%d %d",&n,&e);
	for(int i=1;i<=e;++i){
		scanf("%d %d %d",&u,&v,&d);
		E.push_back(pair<int,int>(v,d));
		E[v].push_back(pair<int,int>(u,d));
	}
	Bellman_Ford(0);
	for(int i=0;i<=n;++i){
		printf("%d %d\n",i,dis);
	}
	return 0;
}

7.1 Prime 贪边法
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+7;
const int INF = 1e9+7;
int dis[MAXN],tot,vis[MAXN];
vector<pair<int,int> > E[MAXN];
int n,e,u,v,d; 
void Prime(){
	for(int i=1;i<=n;++i){
		dis = INF;
	}
	dis[0] = 0;
	for(int k=0;k<=n;++k){
		int val = INF,pos = -1;
		for(int i=0;i<=n;++i){
			if(dis<val&&vis==0){
				val = dis;
				pos = i;
			}
		} 	
		cout<<pos<<" "<<val<<endl;
		tot+=val;
		vis[pos] = 1;
		for(int i=0;i<E[pos].size();++i){
			int to = E[pos].first;
			int dist = E[pos].second;
			if(vis[to]==0)
				dis[to] = min(dis[to],dist);
		}
	}
}
int main(){
	scanf("%d %d",&n,&e);
	for(int i=1;i<=e;++i){
		scanf("%d %d %d",&u,&v,&d);
		E.push_back(pair<int,int>(v,d));
		E[v].push_back(pair<int,int>(u,d));
	}
	
	Prime();
	cout<<tot;
	return 0;
}

7.2 Kruskal 贪点法
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+7;
const int MAXE = 1e8+7;
struct Edge{
	int from,to,dist;
};
bool myCmp(Edge x,Edge y){
	return x.dist<y.dist;
} 
Edge edge[MAXE];
int n,e,u,v,d,fa[MAXN],tot,cnt;
int find_baba(int x){
	while(x!=fa[x]){
		x = fa[x];
	}
	return x;
}
int find_baba_fast(int x){
	int tx = x;
	while(x!=fa[x]){
		x = fa[x];
	}
	int tmp;
	while(tx!=x){
		tmp = tx;
		tx = fa[tx];
		fa[tmp] = x;
	}
	return x;
}
int UnionSet(int x,int y){
	int tx = find_baba_fast(x);
	int ty = find_baba_fast(y);
	if(tx!=ty){
		fa[tx] = ty;
		return 1;
	}else{
		return 0;
	}
}
void Kruskal(){
	sort(edge,edge+e,myCmp);
	for(int i=0;i<=n;++i){
		fa = i;
	}
	for(int i=0;cnt<n&&i<e;i++){
		if(UnionSet(edge.from,edge.to)==1){
			cout<<edge.from<<" "<<edge.to<<" "<<edge.dist<<endl;
			tot+=edge.dist;
			cnt++;
		}	
	}
}
int main(){
	cin>>n>>e;
	for(int i=0;i<e;++i){
		cin>>edge.from>>edge.to>>edge.dist;
	}
	Kruskal();
//	for(int i=0;i<=n;++i){
//		cout<<i<<" "<<fa<<endl;
//	}
	cout<<tot;
	return 0;
}
