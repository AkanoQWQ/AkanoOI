## 前言

咱 OI 生涯独立做出来的第二道黑题，给孩子激动坏了，赶紧交一篇题解。  

可能不算最优解（甚至会被卡空间），但是是一个比较符合正常人思路的题解

## 思路

首先我们需要猜出一个结论，同一深度的点肯定尽可能相同（咱想了好久才想到）。为什么呢？如果没有 $a$ 的数量的限制的话，只要每个深度的字符都一样，答案肯定是 $dep$。但是如果有 $a$ 的数量的限制的话，我们就需要修改一些 $a$ 变成 $b$ 或者反过来。  

第二个结论比较好猜，要修改来满足 $a$ 的个数的点，肯定尽可能靠下方。因为一个点修改后会影响它和它的子树内的所有点对应的字符串，显然影响越少越好。  

看题解还有第三个结论，最多只会有一层点为了满足 $a$ 的限制而修改。咱没有发现这个性质，但是并不影响做题。事实上这个结论挺好想的，如果必须修改两层才能满足要求的话，有一层必定填满，那么它的字符也相同了。  

集齐了三大性质后我们就来做题了。咱把题目分成了两部分来做，先“**整块**”地确定每一层应该统一填 $a$ 还是 $b$，然后“**散块**”地确定哪些地方要为了满足 $a$ 的数量的要求而取反。  

每一层可以选为 $a$ 带来 $size$（层的大小）个 $a$ 的贡献，或者不选带来 $0$ 个 $a$ 的贡献，显然是一个背包模型。然而发现背包大小为 $n$，物品有 $n$ 个，复杂度 $O(n^2)$，无法通过。  

然后就到了咱认为是本体精髓的地方了，每当到这种遇到状态数带来的时空复杂度瓶颈，咱们都可以**大胆猜测状态数很少**（举两个例子，[淘金](https://www.luogu.com.cn/problem/P3303) 的状态数；一个数 $x$ 最多有 $\log_2 x$ 个质因数）。因为很多时候状态数之间会有一种函数关系，导致最终时空复杂度其实是可以保证的。  
	
	回到本题来，我们大胆推测大小（含义是某一层的节点个数）不同的物品实际很少，因为不同大小最优取 $1,2,3 \dots$ 时只有 $\sqrt n$ 个不同物品。那如果有很多个相同物品呢？比如说一条链的情况？我们这时候把它看做一个多重背包，合并大小相同的物品并二进制处理。最终我们只会有大概 $\sqrt n$ 个物品（二进制分组带来的 $\log$ 影响很小，很多时候是负贡献，思考一下）   
	
	于是我们直接背包。咱没有使用各位大佬的 `bitset` 优化，而是直接开了一个 `int` 数组（记住这个 `int` 的伏笔）记录前驱，这样也方便输出方案（各位应该知道通过记录前驱可以输出背包的方案）。  
	
	背包完毕了以后，我们可以通过“整块”分配出某些 $a$ 的个数，可能这些值并不等于 $x$，我们选择一个最接近 $x$ 的然后补泉剩下的差值。我们通过拆分背包的方案知道了对于大小为 $size$ 的层数，有多少个需要分配为泉部都是 $a$，剩下的泉部都是 $b$。具体怎么分配呢？同样大小的层数可能有很多个耶。  
	
	咱没有看到别的巨佬在这里思考，可能是咱想多了吧。假设我们背包出来的值小于 $x$，说明需要多一些 $a$，那么我们需要把 $b$ 改为 $a$，又希望改变的地方尽可能深度大（第二个结论，这样影响更小）。所以当背包出来的值小于 $x$ 的时候，把泉部为 $a$ 的节点放在上方，反之则反过来做。  
	
	然后我们把从下往上枚举，通过取反某些字符来补上背包出来的值和 $x$ 的差值，然后输出就好啦~糟糕的是咱有了方案竟然不知道怎么输出第一个答案（可以通过第三个性质算）......一个哈希给水过去了（  
	
	很可恶，毒瘤题卡咱空间！咱调了半天甚至想用 `bool + unsigned short` 卡空间，最后发现只需要微调一下数组大小就卡过去了......算啦，能过就好~
