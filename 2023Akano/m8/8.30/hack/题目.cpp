/*
## 题目背景 
pure__Elysia 正在做一道 Akano 出的题，聪明的 pure__Elysia 一眼就看出了这道题可以用哈希表轻松地解决，所以他快速写了一个哈希表切了这道题。  
然而 pure__Elysia 明白 Akano 非常心机，这个毒瘤出题人肯定会想尽办法卡掉这么容易想到的算法。  
我们都知道，哈希表的复杂度可以看做常数复杂度(尽管这并不精准)，然而，在出现哈希碰撞的情况下，其复杂度最高是 $O(n)$ 的。  
为了防止普通的哈希被卡掉，聪明的 pure__Elysia 开发了一个泉新的哈希算法，其代码如下:  
```cpp
const int base = 11;
const int mod = 10181108;
long long MyHash(long long x){
	long long a = base,hashVal = 1;
	while(x){
		if(x & 1)hashVal = (hashVal * a) % mod;
		a = (a * a) % mod;
		x >>= 1;//等价于 x /= 2; 
	}
	return hashVal;
}
```
其中的`base`与`mod`是常量  
然而毒瘤出题人 Akano 在拿到了 pure_Elysia 的代码后，想要欺负欺负他，于是决定马上造出对应的数据把他的代码卡成 TLE！  
但是 Akano 没有精力去造 hack 数据了，所以他请求你造出一组数据使得 pure_Elysia 的代码运行的时间复杂度最高。   

## 题目描述
容易证明，在所有数据都哈希碰撞的情况下，pure__Elysia 代码的时间复杂度最高，所以你需要构造出一组数据使得这组数据内的**所有**哈希值都相同。  
题目没有限制数据的 $n$ 的大小，你可以构造出一组最大（ $n$ 最大）的数据，只要这组数据内元素两两哈希碰撞。   
题目有一个数据范围 $maxval$ 表示数据内容的最大值，数据范围为 $0 \le data \le maxval$。另外，由于题目的限制，第一个值 $x$ 已经给出，  
同时你也会获得到 pure__Elysia 程序中的常量 $base$ 与 $mod$，其含义在上文代码中  
因为 pure__Elysia 对代码有极高的审美要求，$base$ 与 $mod$ **一定是互质的**   
请你输出你构造出的数据大小，然后**升序**输出你的数据（包括给出的第一个值）   

## 输入格式
一行四个整数 $x$，$maxval$，$base$，$mod$   
分别为 数据的第一个值，数据最大值，哈希基底值，哈希模数   

## 输出格式
第一行一个整数 $n$ 表示你构造出的 $n$ 最大的数据的大小   
第二行 $n$ 个整数，为你构造出的数据，请升序输出并包含给定的 $x$   

## 输入输出样例
**样例输入1**  
```
2 37 3 7
```
**样例输出1**  
```
6
2 8 14 20 26 32
``` 
**样例输入2**  
```
1018 1108 13 2006
```
**样例输出2**  
```
9
90 206 322 438 554 670 786 902 1018
``` 

## 提示及数据范围  
对于 $100\%$ 的数据，有：   
$0 \le x \le maxval \le maxval \le 10^{10}$  
$1 \le base \le mod \le 10^9$  
$base$ 与 $mod$ 互质   
对于 $40\%$ 的数据，有：   
$0 \le x \le maxval \le maxval \le 10^{5}$  
$1 \le base \le mod \le 10^8$  
另外，如果你实在看不懂，pure__Elysia 的哈希是一个快速幂 
*/
