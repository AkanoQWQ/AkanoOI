# 肖志昊的20221111总结

> ~~不可以,总司令  ——By CCF~~
>
> 旅みたいだね，										    如同旅程一样啊，
> 生きるってどんな時でも，					     活着什么的 无论何时，
> 木枯らしの中，										    寒风中漂泊，
> ぬくもり求め 彷徨う，							    徘徊寻找着温暖，
> 泣かないで わたしの恋心，						不要哭泣啊 我的爱恋之心，
> 涙はお前にはにあわない，						 眼泪和 "你" 并不相配，
> ゆけ ただゆけ，										   走吧 只是向前，
> いっそわたしがゆくよ，							 我已下定决心就这样大步向前。
>
> ​																												————冬の花

## 总总结(题目)

|          |    20221107    |     20221108      |   20221109    |        20221110        |     20221111      |
| :------: | :------------: | :---------------: | :-----------: | :--------------------: | :---------------: |
|   $T1$   |  传送带(tran)  | 最小公倍数(eegcd) | 要有光(small) |    奇怪的游戏(game)    |    塔防(cover)    |
|   $T2$   |  计算器(calc)  |   网络(worknet)   |  那就删(gcd)  | Blinker 的仰慕者(fans) | 题目排版(reverse) |
|   $T3$   |  消耗战(war)   |    序列(aaseq)    |  宝石碗(mul)  |       滑雪(ski)        | 异或逆序(inverse) |
|   $T4$   | 迷宫探险(maze) |   汽油(petrol)    | 向上走(Hard)  |         Plahte         |       $Nan$       |
|   难度   |    蓝蓝紫紫    |      $ Nan $      |    *蓝\*紫    |        紫黑蓝*         |       *蓝蓝       |
| 自评难度 |  绿- 蓝 紫 *   |  紫+ 紫+ 紫+ 紫-  | 蓝 蓝 蓝+ 紫- |      蓝+ 黑 蓝+ ?      |     蓝 蓝 蓝+     |


## 题目分析----有意义的题目
题真的太多了，说不完，以下挑几个有意义的题来具体分析，剩下的简单略过：
### 传送带

> 在一个 $2$ 维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段 $\text{AB}$ 和线段 $\text{CD}$。lxhgww 在 $\text{AB}$ 上的移动速度为 $P$，在 $\text{CD}$ 上的移动速度为 $Q$，在平面上的移动速度 $R$。现在 lxhgww 想从 $\text A$ 点走到 $\text D$ 点，他想知道最少需要走多长时间。

按理来说他是蓝，不仅如此，算上证明难度还应该是蓝+。但是，咱是人类，咱有一个特殊能力，叫做感性理解。我们可以蒙，我们猜测两条线段上取两个点，移动他们，移动的比例呈两个单峰函数！我们可以通过实数枚举对拍来保证这一点。它的证明非常难，但是并不必要（这导致咱被某人乱 $ \% $ ，然而事实上咱确实不会数学证明啊  ╮(╯▽╰)╭）。所以我们就感性做出了这题（之后就非常简单了，显然两个三分，一个套另外一个）

### 汽油 & 滑雪

这两道题都是最小生成树的变种，一眼看上去有点像最小生成树，但是都不好写（无法套板子，需要魔改）

这两道题的意义是扩展了最小生成树的思路，以及积累魔改算法的经验。

## 其他题的总结

#### 计算器

很裸的数学题，但是咱数论确实太差了，于是只写出来一个`ksm`。说明以后数论知识还有待加强。数论清单：

- 组合数学
- 线性代数
- EXGCD/中国剩余定理

#### 消耗战

一个很裸的虚树题，属于做过这种类型的题就可以切的题。But，咱就是没做过虚树的题啊（- w - ）。现在还应该多做两道虚树的题巩固下，因为虚树的难点部分（压栈的过程）咱还不是很熟，事实上也没有理解。

#### 迷宫探险

期望+搜索，然而到现在也没有改出来。因为概率什么的是在不好写啊。这道题倒是貌似没有用到什么很高级的算法，大概可以看做高级大模拟？

#### 最小公倍数

需要用到分块思想的图论题，但是不需要用到图论算法。提醒咱得再学习下分块了。

考试的时候貌似没有写出得分的暴力，算是一个失误。

#### 网络

**输出答案的下标写错，暴力爆零**，最不应该出现的错误。

写了一个不是很暴力的暴力（貌似有LCA？），理论上来说可以拿一些部分分，然而下标整错力。

正解上来说这是一道叠buff题，内容包括但不限于二分，树状数组，树链剖分，LCA，树上差分......码量思维都很恐怖。

#### 序列

正解回滚莫队（或者有一个二维的做法），咱前段时间才学回滚莫队，所以还没有改这道题。后面可以尝试着做一下。然而预处理的思维难度就已经不低了......状态转移感觉不好想

## 部分题解

### XOR Inverse 题面

#### 题面翻译

给定长度为 $n$ $(1\le n\le3\times 10^5)$ 的数列 $\{a_n\}$ $(0\le a_n\le 10^9)$，请求出最小的整数 $x$ 使 $\{a_n\oplus x\}$ 的逆序对数最少，其中 $\oplus$ 是异或

输入格式

第一行 $n$，第二行 $\{a_n\}$

输出格式

两个数，逆序对数和 $x$

#### 题目描述

You are given an array $ a $ consisting of $ n $ non-negative integers. You have to choose a non-negative integer $ x $ and form a new array $ b $ of size $ n $ according to the following rule: for all $ i $ from $ 1 $ to $ n $ , $ b_i = a_i \oplus x $ ( $ \oplus $ denotes the operation [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)).

An inversion in the $ b $ array is a pair of integers $ i $ and $ j $ such that $ 1 \le i < j \le n $ and $ b_i > b_j $ .

You should choose $ x $ in such a way that the number of inversions in $ b $ is minimized. If there are several options for $ x $ — output the smallest one.

#### 输入格式

First line contains a single integer $ n $ ( $ 1 \le n \le 3 \cdot 10^5 $ ) — the number of elements in $ a $ .

Second line contains $ n $ space-separated integers $ a_1 $ , $ a_2 $ , ..., $ a_n $ ( $ 0 \le a_i \le 10^9 $ ), where $ a_i $ is the $ i $ -th element of $ a $ .

#### 输出格式

Output two integers: the minimum possible number of inversions in $ b $ , and the minimum possible value of $ x $ , which achieves those number of inversions.

#### 样例
```
9
10 7 9 10 7 5 5 3 5
```
```
4 14
```
### 思路
因为涉及到异或操作，当然也是位运算的一种，我们可以想到建立一棵`01trie`。

在做这道题以前咱一次`01trie`都没写过，所以这里重点介绍一下

`01trie`相似于`trie`，每个节点至多有两个子节点，表示下一个位的值为 $ 0 $ 或 $ 1 $ 。每个节点都有一个隐藏的值，当前位（这是由创建这个节点的时候递归的位决定的）。这棵树有一个性质，右节点代表的数的值一定比左节点的值大（我们定义右节点代表 $ 1 $，于是这就是显而易见的了），这是极好的，很方便我们求逆序对。

于是我们根据`a[i]`中的每一个数建立一棵`01trie`（实现见代码），用这颗`01trie`维护当前数的下标（毕竟要求逆序对），由于插入的下标是根据顺序递增的，它具有单调性，非常方便我们之后的操作（双指针求逆序对）。

对于每一个节点，它带来的总数对个数位左节点的大小乘以右节点的大小（显然），而逆序对可以根据如下代码求出（不做具体解释）：
```cpp
ll ret = 0;
for(int i = 0;i < p[lchild].size();i++){
	const ll lpos = p[lchild][i];
	while(num < p[rchild].size() && p[rchild][num] < lpos){
		num++;
	}
	ret += num;
}
```
`p[lchild/rchild]`里存的是有严格上升单调性的下标，于是这段代码就不难理解了（由于有单调性，于是可以使用双指针）

最后我们统计答案，枚举每一位到底是异或（相当于交换左右节点，使得逆序对的个数变成(总数对个数-原逆序对个数)）还是不异或更优，**每一位是独立的，于是贪心选择**。
### 代码
```cpp
#define ll long long
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 3e5 + 9;
int child[MAXN*31][2],tot = 1;
int a[MAXN];
vector<int> p[MAXN * 31];
ll f[33][2];
void insert(int u,int num,int pos,int wei){
	if(wei < 0)return ;
	const int c = (num>>wei) & 1;
	if(!child[u][c])child[u][c] = ++tot;
	p[child[u][c]].push_back(pos);
	insert(child[u][c],num,pos,wei-1);
	return ;
}
void dfs(int u,int wei){
	const int lchild = child[u][0];
	const int rchild = child[u][1];
	if(lchild)dfs(lchild,wei-1);
	if(rchild)dfs(rchild,wei-1);
	if(!lchild && !rchild)return ;
	int num = 0;
	ll ret = 0;
	for(int i = 0;i < p[lchild].size();i++){
		const ll lpos = p[lchild][i];
		while(num < p[rchild].size() && p[rchild][num] < lpos){
			num++;
		}
		ret += num;
	}
	f[wei][0] += ret;
	f[wei][1] += 1ll * p[lchild].size() * p[rchild].size() - ret;
	return ;
}
ll answ,ansx;
int n;
int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n;i++){
		scanf("%d",&a[i]);
		insert(1,a[i],i,30);
	}
	dfs(1,30);
	for(int i = 30;i >= 0;--i){
		answ += min(f[i][0],f[i][1]);
		if(f[i][1] < f[i][0]){
			ansx |= (1ll<<i);
		}
	}
	printf("%lld %lld",answ,ansx);
	return 0;
}
```

## 总总总结

这几天得题目揭露了基础知识上的短缺，知识结构仍有不足（虚树，数论，莫队......）。接下来的时间内应该加紧补充知识结构，最重要的是巩固，使得不会有“知道怎么做但是不会写”的情况。

## 传统习俗

> **樱若有花必有情，此间花开彼此恋**
>
> **此花亭者，有缘者遇之，有心者留之，有向者去之，有情者爱之**。
>
> 
>
> 千年沉浮恋妖世，
>
> 万载奇谭此花亭。
>
> 樱若有花必有亭，
>
> 此间花开彼间恋。
>
> ​											————《此花亭奇谭》

![1](D:\Main\md\pic\1.jpg)

![2](D:\Main\md\pic\2.jpg)
