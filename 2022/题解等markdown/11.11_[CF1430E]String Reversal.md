## String Reversal 题面
### 题目描述
You are given a string $ s $ . You have to reverse it — that is, the first letter should become equal to the last letter before the reversal, the second letter should become equal to the second-to-last letter before the reversal — and so on. For example, if your goal is to reverse the string "abddea", you should get the string "aeddba". To accomplish your goal, you can swap the neighboring elements of the string.

Your task is to calculate the minimum number of swaps you have to perform to reverse the given string.
### 题面翻译
给定一个长度为$n$的字符串$A$，$B$为翻转后的$A$字符串，请你求出$B$最少需要多少次相邻字符互换操作才能与$A$完全一致。$1\le n \le 2\times10^5$
#### 样例
```
9
icpcsguru
```
```
30
```
## 思路

如果每个字母只出现一次,那么我们是好解决这个问题的，另一个数组，每个元素的值为当前下标对称以后的值，意味着需要把该元素移动到此位置。我们求一遍逆序对就可以得出答案。

但是一个字母可能会出现多次，我们可以感性理解到以下两种策略：

- 每个元素选择反转后离自己最远的一个元素
- 每个元素选择反转后离自己更近的一个元素

两种方法粗略想起来貌似都有道理：方法A可能在交换的过程中"顺带"带走了几个需要的元素；方法B自不必说，选择离自己最近的

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 5;
int a[MAXN],b[MAXN];
long long ans;
void msort(int l,int r){
	if(l == r)return ;
	const int mid = (l + r) >> 1;
	msort(l,mid);
	msort(mid+1,r);
	int i = l;
	int j = mid + 1;
	int t = l;
	while(i <= mid && j <= r){
		if(a[i] > a[j]){
			ans += mid - i + 1;
			b[t++] = a[j];
			++j;
		}else{
			b[t++] = a[i];
			++i;
		}
	}
	while(i <= mid){
		b[t++] = a[i];
		++i;
	}
	while(j <= r){
		b[t++] = a[j];
		++j;
	}
	for(int i = l;i <= r;i++){
		a[i] = b[i];
	}
	return ;
}
int n;
deque<int> q[28];
string s;
int obj[MAXN];
int main(){
	cin>>n>>s;
	s = "." + s + ".";
	for(int i = 1;i <= n;i++){
		q[s[i]-'a'].push_back(i);
	}
	for(int i = 0;i < 26;i++){
		while(q[i].size() >= 2){
			const int u = q[i].front();
			const int v = q[i].back();
			q[i].pop_front(),q[i].pop_back();
			obj[u] = v,obj[v] = u;
		}
		if(q[i].size() == 1){
			const int u = q[i].front();
			obj[u] = u;
			q[i].pop_back();
		}
	}
	for(int i = 1;i <= n;i++){
		a[i] = n - obj[i] + 1;
	}
	msort(1,n);
	printf("%lld",ans);
	return 0;
}
```

