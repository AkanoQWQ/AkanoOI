Desire: 

考虑一次扩展子节点只影响两个深度，且顺序无影响，不妨令处理的d单调，并且于一次转移整层，可以只保存两个深度作为状态(i,d,a,b)已经处理了i个点，当前处理深度为d，深度为d的点a个，d+1为b个。优化d的那一维度，发现可以省略d，而直接在转移时加上后续影响，状态变为(i,a,b)，观察发现转移式子前两位之和为定值，用g(n,m)记录转移所需min

时间O(n^3),空间滚动优化O(n^2)



Dealing:

key：可以发现此问题的最多有效操作必在o（n）内,那么尝试降低无效操作次数

可以把操作堆叠，但不能堆叠于底层，否则会T，于是尝试从长向短逐步去重

用二进制拆分把长度拆分为许多二进制长度(P1)，最后从长度最长的部分

开始，每一层长度在并查集的时候都去重本层长度，再把去重后的结果

推到下一层去，最终达到目的(P2)

(忽略并查集复杂度)	O(m*lgn(P1)+n*lgn(P2)）



lunatic:

想了很久才终于找到了key,关键在于这个问题的一个下界：

前k-1个独自成组,那么就可以得出任何含有交集为0的方案的

ans不可能大于它，因而答案为max(max（全部有交集的方案),此下界e

(

​	全部有交集的时侯

​	若不考虑有线段相互包含时满足选择的线段的连续性

​	否则考虑将包含别人的线段提出来，它们的选取组数记为v

​	因为这种线段可以和被包含的线段组合而被忽略掉

​	记ANS1 a为在此类中选取a组的max

​	ANS2 a则为在非此类中选a组的max

​	因而ANS1 v=此类线段的前v长的线段

​	即求 max(ANS1 v+ANS2 k-v)

)

/

*season:*

/
